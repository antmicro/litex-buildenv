import os
import sys
import struct

from litex.build.xilinx import common

from litex.build.tools import write_to_file, get_litex_git_revision, subprocess_call_filtered, cygpath
from distutils.version import StrictVersion
from distutils.spawn import find_executable

def _versions(path):	
    for n in os.listdir(path):	
        full = os.path.join(path, n)	
        if not os.path.isdir(full):	
            continue	
        try:	
            yield StrictVersion(n)	
        except ValueError:	
            continue


def _arch_bits():	
    return struct.calcsize("P")*8


def _find_xilinx_settings(path, sub=None):	
    vers = list(_versions(path))	
    if not vers:	
        raise OSError("no version directory for Xilinx tools found in "	
                      + path)	
    ver = max(vers)	

    full = os.path.join(path, str(ver))
    
    if sub:
        full = os.path.join(full, sub)

    search = [64, 32]	
    if _arch_bits() == 32:	
        search.reverse()	

    if sys.platform == "win32" or sys.platform == "cygwin":	
        script_ext = "bat"	
    else:	
        script_ext = "sh"	

    for b in search:	
        settings = os.path.join(full, "settings{0}.{1}".format(b, script_ext))	
        if os.path.exists(settings):	
            return settings	

    raise OSError("no Xilinx tools settings file found")	


def vivado_build_script(build_name, vivado_path):
    if not vivado_path:
        # fall-back to the default location
        vivado_path = '/opt/Xilinx/'

    if sys.platform in ["win32", "cygwin"]:
        script_contents = "REM Autogenerated by LiteX / git: " + get_litex_git_revision() + "\n"
        script_contents += "vivado -mode batch -source " + build_name + ".tcl\n"
        script_file = "build_" + build_name + ".bat"
        write_to_file(script_file, script_contents)
    else:
        script_contents = "# Autogenerated by LiteX / git: " + get_litex_git_revision() + "\n"
        script_contents += "# Modified by litex-buildenv\n"
        script_contents += "set -e\n"

        if not find_executable("vivado"):
            # Only source Vivado settings if not already in our $PATH
            # if not find_executable("vivado"):
            # For backwards compatibility with ISE paths, also
            # look for a version in a subdirectory named "Vivado"
            # under the current directory.
            paths_to_try = [vivado_path, os.path.join(vivado_path, "Vivado")]
            for p in paths_to_try:
                try:
                    settings = _find_xilinx_settings(p)
                except OSError:
                    continue
                break
            else:
                raise OSError("Unable to locate Vivado directory or settings.")
            script_contents += "source " + settings + "\n"

        script_contents += "vivado -mode batch -source " + build_name + ".tcl\n"
        script_file = "build_" + build_name + ".sh"
        write_to_file(script_file, script_contents)
    return script_file


def ise_run(build_name, mode, ngdbuild_opt, toolchain, platform, ise_path):
    if sys.platform == "win32" or sys.platform == "cygwin":

        if ise_path is None:
            if sys.platform == "win32":
                ise_path = "C:\\Xilinx"
            else:
                ise_path = "/cygdrive/c/Xilinx"

        script_ext = ".bat"
        shell = ["cmd", "/c"]
        source_cmd = "call "
        build_script_contents = "@echo off\nrem Autogenerated by LiteX / git: " + get_litex_git_revision() + "\n"
        build_script_contents += "rem Modified by litex-buildenv\n"
        fail_stmt = " || exit /b"
    else:
        if ise_path is None:
            ise_path = "/opt/Xilinx"

        script_ext = ".sh"
        shell = ["bash"]
        source_cmd = "source "
        build_script_contents = "# Autogenerated by LiteX / git: " + get_litex_git_revision() + "\n"
        build_script_contents += "# Modified by litex-buildenv\n"
        build_script_contents += "set -e\n"
        fail_stmt = ""

    settings = _find_xilinx_settings(ise_path, "ISE_DS")	
    build_script_contents += source_cmd + cygpath(settings) + "\n"	

    if mode == "edif":
        ext = "ngo"
        build_script_contents += """
edif2ngd {build_name}.edif {build_name}.{ext}{fail_stmt}
"""
    else:
        ext = "ngc"
        build_script_contents += """
xst -ifn {build_name}.xst{fail_stmt}
"""

    # This generates a .v file for post synthesis simulation
    build_script_contents += """
netgen -ofmt verilog -w -sim {build_name}.{ext} {build_name}_synth.v
"""

    build_script_contents += """
ngdbuild {ngdbuild_opt} -uc {build_name}.ucf {build_name}.{ext} {build_name}.ngd{fail_stmt}
"""
    if mode == "cpld":
        build_script_contents += """
cpldfit -ofmt verilog {par_opt} -p {device} {build_name}.ngd{fail_stmt}
taengine -f {build_name}.vm6 -detail -iopath -l {build_name}.tim{fail_stmt}
hprep6 -s IEEE1532 -i {build_name}.vm6{fail_stmt}
"""
    else:
        build_script_contents += """
map {map_opt} -o {build_name}_map.ncd {build_name}.ngd {build_name}.pcf{fail_stmt}
par {par_opt} {build_name}_map.ncd {build_name}.ncd {build_name}.pcf{fail_stmt}
bitgen {bitgen_opt} {build_name}.ncd {build_name}.bit{fail_stmt}
"""
    build_script_contents = build_script_contents.format(build_name=build_name,
            ngdbuild_opt=ngdbuild_opt, bitgen_opt=toolchain.bitgen_opt, ext=ext,
            par_opt=toolchain.par_opt, map_opt=toolchain.map_opt,
            device=platform.device, fail_stmt=fail_stmt)
    build_script_contents += toolchain.ise_commands.format(build_name=build_name)
    build_script_file = "build_" + build_name + script_ext
    write_to_file(build_script_file, build_script_contents, force_unix=False)
    command = shell + [build_script_file]
    r = subprocess_call_filtered(command, common.colors)
    if r != 0:
        raise OSError("Subprocess failed")
